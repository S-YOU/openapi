package types

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/pkg/errors"
)

var entityTypes = map[string]interface{}{}
var postUnmarshalJSONHooks = map[string]struct{}{
	"pathItem": struct{}{},
}

func GenerateCode() error {
	entities := []interface{}{
		callback{},
		components{},
		contact{},
		discriminator{},
		encoding{},
		example{},
		externalDocumentation{},
		header{},
		info{},
		license{},
		link{},
		mediaType{},
		oAuthFlow{},
		oAuthFlows{},
		openAPI{},
		operation{},
		parameter{},
		pathItem{},
		paths{},
		reference{},
		requestBody{},
		response{},
		responses{},
		schema{},
		securityRequirement{},
		securityScheme{},
		server{},
		serverVariable{},
		tag{},
	}

	for _, e := range entities {
		name := reflect.ValueOf(e).Type().Name()
		entityTypes[name] = e
	}

	// Copy the interfaces file after swapping the package name
	copyInterface()

	for _, e := range entities {
		if err := generateJSONHandlersFromEntity(e); err != nil {
			return errors.Wrap(err, `failed to generate JSON handlers from entity`)
		}
		if err := generateAccessorsFromEntity(e); err != nil {
			return errors.Wrap(err, `failed to generate accessors from entity`)
		}

		if err := generateBuildersFromEntity(e); err != nil {
			return errors.Wrap(err, `failed to generate builders from entity`)
		}
	}

	if err := generateClonersFromEntity(entities); err != nil {
		return errors.Wrap(err, `failed to generate cloners from entity list`)
	}

	return nil
}

func snakeCase(in string) string {
	runes := []rune(in)
	length := len(runes)

	var out []rune
	for i := 0; i < length; i++ {
		if i > 0 && unicode.IsUpper(runes[i]) && ((i+1 < length && unicode.IsLower(runes[i+1])) || unicode.IsLower(runes[i-1])) {
			out = append(out, '_')
		}
		out = append(out, unicode.ToLower(runes[i]))
	}

	switch s := string(out); {
	case strings.Contains(s, "open_api"):
		return strings.Replace(s, "open_api", "openapi", -1)
	case strings.Contains(s, "o_auth"):
		return strings.Replace(s, "o_auth", "oauth", -1)
	default:
		return s
	}
}

func ucfirst(s string) string {
	if len(s) <= 0 {
		return s
	}

	r, w := utf8.DecodeRuneInString(s)
	var buf bytes.Buffer
	buf.WriteRune(unicode.ToUpper(r))
	buf.WriteString(s[w:])
	return buf.String()
}

func lcfirst(s string) string {
	if len(s) <= 0 {
		return s
	}

	switch s {
	case "URL":
		return "url"
	}

	r, w := utf8.DecodeRuneInString(s)
	var buf bytes.Buffer
	buf.WriteRune(unicode.ToLower(r))
	buf.WriteString(s[w:])
	return buf.String()
}

func exportedFieldName(s string) string {
	n := ucfirst(s)
	switch n {
	case "DefaultValue":
		return "Default"
	case "Typ":
		return "Type"
	default:
		return n
	}
}

func unexportedFieldName(s string) string {
	n := lcfirst(s)
	switch n {
	case "default":
		return "defaultValue"
	case "type":
		return "typ"
	default:
		return n
	}
}

func typname(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Interface:
		if t.Name() == "" {
			return "interface{}"
		}
		return t.Name()
	case reflect.Ptr:
		return "*" + typname(t.Elem())
	case reflect.Slice:
		return "[]" + typname(t.Elem())
	case reflect.Map:
		return "map[" + typname(t.Key()) + "]" + typname(t.Elem())
	default:
		return t.Name()
	}
}

func writePreamble(dst io.Writer) {
	fmt.Fprintf(dst, "\n\npackage openapi")
	fmt.Fprintf(dst, "\n\n// This file was automatically generated by genbuilders.go on %s", time.Now().Format(time.RFC3339))
	fmt.Fprintf(dst, "\n// DO NOT EDIT MANUALLY. All changes will be lost\n")
}

var importDummies = map[string]string{
	"github.com/pkg/errors": "errors.Cause",
}

func writeImports(dst io.Writer, pkgs []string) {
	fmt.Fprintf(dst, "\n\nimport (")
	for _, pkg := range pkgs {
		fmt.Fprintf(dst, "\n%s", strconv.Quote(pkg))
	}
	fmt.Fprintf(dst, "\n)")

	// check to see if we need dummies
	var buf bytes.Buffer
	for _, pkg := range pkgs {
		if v, ok := importDummies[pkg]; ok {
			fmt.Fprintf(&buf, "\nvar _ = %s", v)
		}
	}

	if buf.Len() > 0 {
		fmt.Fprintf(dst, "\n")
		buf.WriteTo(dst)
	}
}

func copyInterface() error {
	log.Printf("Generating interface.go")

	var buf bytes.Buffer
	var dst io.Writer = &buf

	src, err := os.Open(filepath.Join("internal", "types", "interface.go"))
	if err != nil {
		return errors.Wrapf(err, `failed to open source file`)
	}

	scanner := bufio.NewScanner(src)

	// throw away first N lines
	for scanner.Scan() {
		txt := scanner.Text()
		if txt == "package types" {
			break
		}
	}

	writePreamble(dst)

	for scanner.Scan() {
		txt := scanner.Text()
		fmt.Fprintf(dst, "\n%s", txt)
		if strings.HasPrefix(txt, "type ") && strings.HasSuffix(txt, " interface {") {
			i := strings.Index(txt[5:], " ")
			completeInterface(dst, txt[5:5+i])
		}
	}
	if err := writeFormattedSource(&buf, "interface_gen.go"); err != nil {
		return errors.Wrap(err, `failed to write result to file`)
	}
	return nil
}

func completeInterface(dst io.Writer, ifacename string) {
	log.Printf("Completing interface for %s", ifacename)

	e, ok := entityTypes[lcfirst(ifacename)]
	if !ok {
		panic(fmt.Sprintf("Could not find value for %s", lcfirst(ifacename)))
	}

	rv := reflect.ValueOf(e)

	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		fmt.Fprintf(dst, "\n%s() %s", exportedFieldName(fv.Name), typname(fv.Type))
	}
	fmt.Fprintf(dst, "\nClone() %s", ifacename)
}

func generateJSONHandlersFromEntity(e interface{}) error {
	rv := reflect.ValueOf(e)
	switch rv.Type().Name() {
	case "paths", "responses":
		return nil
	}

	filename := fmt.Sprintf("%s_json_gen.go", snakeCase(rv.Type().Name()))
	log.Printf("Generating %s", filename)

	var buf bytes.Buffer
	var dst io.Writer = &buf

	writePreamble(dst)

	writeImports(dst, []string{"encoding/json", "github.com/pkg/errors"})

	mpname := rv.Type().Name() + "MarshalProxy"
	upname := rv.Type().Name() + "UnmarshalProxy"

	fmt.Fprintf(dst, "\n\ntype %s struct {", mpname)
	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		fmt.Fprintf(dst, "\n%s %s `%s`", exportedFieldName(fv.Name), typname(fv.Type), fv.Tag)
	}
	fmt.Fprintf(dst, "\n}")

	fmt.Fprintf(dst, "\n\ntype %s struct {", upname)
	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		if _, ok := entityTypes[unexportedFieldName(typname(fv.Type))]; ok {
			fmt.Fprintf(dst, "\n%s json.RawMessage `%s`", exportedFieldName(fv.Name), fv.Tag)
		} else {
			fmt.Fprintf(dst, "\n%s %s `%s`", exportedFieldName(fv.Name), typname(fv.Type), fv.Tag)
		}
	}
	fmt.Fprintf(dst, "\n}")

	fmt.Fprintf(dst, "\n\nfunc (v *%s) MarshalJSON() ([]byte, error) {", rv.Type().Name())
	fmt.Fprintf(dst, "\nvar proxy %s", mpname)
	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		fmt.Fprintf(dst, "\nproxy.%s = v.%s", exportedFieldName(fv.Name), unexportedFieldName(fv.Name))
	}
	fmt.Fprintf(dst, "\nreturn json.Marshal(proxy)")
	fmt.Fprintf(dst, "\n}")

	// Unmarshaling interfaces is tricky. We need to construct a concrete
	// type that fulfills the interface, and unmarshal using that.

	fmt.Fprintf(dst, "\n\nfunc (v *%s) UnmarshalJSON(data []byte) error {", rv.Type().Name())
	fmt.Fprintf(dst, "\nvar proxy %s", upname)
	fmt.Fprintf(dst, "\nif err := json.Unmarshal(data, &proxy); err != nil {")
	fmt.Fprintf(dst, "\nreturn err")
	fmt.Fprintf(dst, "\n}")
	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		if _, ok := entityTypes[unexportedFieldName(fv.Type.Name())]; ok {
			fmt.Fprintf(dst, "\n\nif len(proxy.%s) > 0 {", exportedFieldName(fv.Name))
			fmt.Fprintf(dst, "\nvar decoded %s", unexportedFieldName(typname(fv.Type)))
			fmt.Fprintf(dst, "\nif err := json.Unmarshal(proxy.%s, &decoded); err != nil {", exportedFieldName(fv.Name))
			fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `failed to unmarshal field %s`)", exportedFieldName(fv.Name))
			fmt.Fprintf(dst, "\n}")
			fmt.Fprintf(dst, "\n\nv.%s = &decoded", unexportedFieldName(fv.Name))
			fmt.Fprintf(dst, "\n}")
		} else {
			fmt.Fprintf(dst, "\nv.%s = proxy.%s", unexportedFieldName(fv.Name), exportedFieldName(fv.Name))
		}
	}

	if _, ok := postUnmarshalJSONHooks[rv.Type().Name()]; ok {
		fmt.Fprintf(dst, "\n\nv.postUnmarshalJSON()")
	}
	fmt.Fprintf(dst, "\nreturn nil")
	fmt.Fprintf(dst, "\n}")

	if err := writeFormattedSource(&buf, filename); err != nil {
		return errors.Wrap(err, `failed to write result to file`)
	}
	return nil
}

func generateAccessorsFromEntity(e interface{}) error {
	rv := reflect.ValueOf(e)
	filename := fmt.Sprintf("%s_accessors_gen.go", snakeCase(rv.Type().Name()))
	log.Printf("Generating %s", filename)

	var buf bytes.Buffer
	var dst io.Writer = &buf

	writePreamble(dst)

	structname := rv.Type().Name()

	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		fmt.Fprintf(dst, "\n\nfunc (v *%s) %s() %s {", structname, exportedFieldName(fv.Name), typname(fv.Type))
		fmt.Fprintf(dst, "\nreturn v.%s", unexportedFieldName(fv.Name))
		fmt.Fprintf(dst, "\n}")
	}

	if err := writeFormattedSource(&buf, filename); err != nil {
		return errors.Wrap(err, `failed to write result to file`)
	}
	return nil
}

func generateBuildersFromEntity(e interface{}) error {
	rv := reflect.ValueOf(e)
	filename := fmt.Sprintf("%s_builder_gen.go", snakeCase(rv.Type().Name()))
	log.Printf("Generating %s", filename)

	var buf bytes.Buffer
	var dst io.Writer = &buf

	writePreamble(dst)

	ifacename := ucfirst(rv.Type().Name())
	structname := rv.Type().Name()

	fmt.Fprintf(dst, "\n\n// %sBuilder is used to build an instance of %s. The user must", ifacename, ifacename)
	fmt.Fprintf(dst, "\n// call `Build()` after providing all the necessary information to")
	fmt.Fprintf(dst, "\n// build an instance of %s", ifacename)
	fmt.Fprintf(dst, "\ntype %sBuilder struct {", ifacename)
	fmt.Fprintf(dst, "\ntarget *%s", structname)
	fmt.Fprintf(dst, "\n}")

	fmt.Fprintf(dst, "\n\n// Build finalizes the building process for %s and returns the result", ifacename)
	fmt.Fprintf(dst, "\nfunc (b *%sBuilder) Build() %s {", ifacename, ifacename)
	fmt.Fprintf(dst, "\nreturn b.target")
	fmt.Fprintf(dst, "\n}")

	// Iterate through the fields, check if they are required / explicitly
	// excluded from certain operations
	var defaults []reflect.StructField
	var requireds []reflect.StructField
	var optionals []reflect.StructField
	for i := 0; i < rv.NumField(); i++ {
		fv := rv.Type().Field(i)
		hasDefault := len(fv.Tag.Get("default")) > 0
		if hasDefault {
			defaults = append(defaults, fv)
		}
		switch fv.Tag.Get("builder") {
		case "-":
			continue // ignore this
		case "required":
			if hasDefault {
				optionals = append(optionals, fv)
			} else {
				requireds = append(requireds, fv)
			}
		default:
			optionals = append(optionals, fv)
		}
	}

	fmt.Fprintf(dst, "\n\n// New%s creates a new builder object for %s", ifacename, ifacename)
	fmt.Fprintf(dst, "\nfunc New%s(", ifacename)
	for i, fv := range requireds {
		fmt.Fprintf(dst, "%s %s", unexportedFieldName(fv.Name), typname(fv.Type))
		if i < len(requireds)-1 {
			fmt.Fprintf(dst, ", ")
		}
	}
	fmt.Fprintf(dst, ") *%sBuilder {", ifacename)
	fmt.Fprintf(dst, "\nreturn &%sBuilder{", ifacename)
	fmt.Fprintf(dst, "\ntarget: &%s{", structname)

	hasDefault := make(map[string]struct{})
	for _, fv := range defaults {
		hasDefault[fv.Name] = struct{}{}
		fmt.Fprintf(dst, "\n%s: %s,", fv.Name, fv.Tag.Get("default"))
	}
	for _, fv := range requireds {
		fmt.Fprintf(dst, "\n%s: %s,", fv.Name, unexportedFieldName(fv.Name))
	}
	fmt.Fprintf(dst, "\n},")
	fmt.Fprintf(dst, "\n}")
	fmt.Fprintf(dst, "\n}")

	for _, fv := range optionals {
		fmt.Fprintf(dst, "\n\n// %s sets the %s field for object %s.", exportedFieldName(fv.Name), exportedFieldName(fv.Name), ifacename)
		if _, ok := hasDefault[fv.Name]; ok {
			fmt.Fprintf(dst, " If this is not called,\n// a default value (%s) is assigned to this field", fv.Tag.Get("default"))
		}
		fmt.Fprintf(dst, "\nfunc (b *%sBuilder) %s(v %s) *%sBuilder {", ifacename, exportedFieldName(fv.Name), typname(fv.Type), ifacename)
		fmt.Fprintf(dst, "\nb.target.%s = v", fv.Name)
		fmt.Fprintf(dst, "\nreturn b")
		fmt.Fprintf(dst, "\n}")
	}

	//	fmt.Fprintf(dst, "\n\nfunc Muatate%s(target *%s) *%sMutator {", rv.Type().Name(), rv.Type().Name(), rv.Type().Name())

	if err := writeFormattedSource(&buf, filename); err != nil {
		return errors.Wrap(err, `failed to write result to file`)
	}
	return nil
}

func generateClonersFromEntity(entities []interface{}) error {
	filename := "cloner_gen.go"
	log.Printf("Generating %s", filename)

	var buf bytes.Buffer
	var dst io.Writer = &buf

	writePreamble(dst)

	for _, e := range entities {
		rv := reflect.ValueOf(e)
		fmt.Fprintf(dst, "\n\nfunc (v *%s) Clone() %s {", rv.Type().Name(), ucfirst(rv.Type().Name()))
		fmt.Fprintf(dst, "\nvar dst %s", rv.Type().Name())
		fmt.Fprintf(dst, "\ndst = *v")
		fmt.Fprintf(dst, "\nreturn &dst")
		fmt.Fprintf(dst, "\n}")
	}

	return writeFormattedSource(&buf, filename)
}

func writeFormattedSource(buf *bytes.Buffer, filename string) error {
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("%s", buf.String())
		return errors.Wrap(err, `failed to format source`)
	}

	f, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return errors.Wrapf(err, `failed to open file %s`, filename)
	}
	defer f.Close()

	f.Write(formatted)

	return nil
}
